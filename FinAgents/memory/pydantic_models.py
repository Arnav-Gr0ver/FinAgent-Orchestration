from typing import Dict, Any, Optional, List, Union
from pydantic import BaseModel, Field, validator
from datetime import datetime
import uuid


class MCPRequestParams(BaseModel):
    agent_id: str
    function: str
    input: Dict[str, Any] 
    meta: Optional[Dict[str, Any]] = Field(default_factory=dict)

class MCPRequest(BaseModel):
    method: str = Field(..., example="agent.execute") 
    params: MCPRequestParams
    id: Optional[Union[str, int]] = Field(default_factory=lambda: str(uuid.uuid4()), example="req-123") # JSON-RPC request ID

class MCPResponseMeta(BaseModel):
    status: str = Field(..., example="success")
    timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())

class MCPErrorData(BaseModel):
    agent_id: Optional[str] = None
    details: Optional[str] = None

class MCPError(BaseModel):
    code: int 
    message: str
    data: Optional[MCPErrorData] = None

class MCPErrorResponse(BaseModel):
    error: MCPError
    id: Optional[Union[str, int]] = None 

class StoreMemoryInput(BaseModel):
    content: str = Field(..., description="The textual content of the memory to store.")
    category: str = Field("General", description="A category for the memory (e.g., 'User Preference', 'Fact').")
    source_agent_id: Optional[str] = Field(None, description="The ID of the agent or source providing this memory.")
    timestamp: Optional[str] = Field(default_factory=lambda: datetime.now().isoformat(), description="ISO 8601 timestamp. Auto-generated if not provided.")
    additional_metadata: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Any other structured data to store with the memory.")

    @validator('timestamp')
    def validate_timestamp_format(cls, v):
        if v is not None:
            try:
                datetime.fromisoformat(v.replace('Z', '+00:00'))
            except ValueError:
                raise ValueError("Timestamp must be a valid ISO 8601 string.")
        return v

class StoreMemoryResult(BaseModel):
    memory_id: str = Field(..., description="Unique identifier for the stored memory.")
    status_message: str = Field(..., example="Memory stored successfully.")
    generated_keywords: List[str] = Field(default_factory=list, description="Keywords generated from memory content by LLM analysis (if available).")
    generated_context: Optional[str] = Field(None, description="A brief context or summary generated by LLM analysis (if available).")

class StoreMemoryResponse(BaseModel):
    result: StoreMemoryResult
    meta: MCPResponseMeta
    id: Optional[Union[str, int]] = None

class RetrieveMemoriesInput(BaseModel):
    query: str = Field(..., description="The search query or question to find relevant memories for.")
    k: int = Field(5, ge=1, le=100, description="The maximum number of memories to retrieve.")

class RetrievedMemoryItem(BaseModel):
    id: str = Field(..., description="Unique identifier of the retrieved memory.")
    document: str = Field(..., description="The textual content of the memory.")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="The metadata associated with the memory.")
    distance: Optional[float] = Field(None, description="The distance score of the memory to the query (lower is better). Present if provided by the retrieval system.")

class RetrieveMemoriesResult(BaseModel):
    retrieved_memories: List[RetrievedMemoryItem]
    status_message: str = Field(..., example="Retrieved X memories.")

class RetrieveMemoriesResponse(BaseModel):
    result: RetrieveMemoriesResult
    meta: MCPResponseMeta
    id: Optional[Union[str, int]] = None